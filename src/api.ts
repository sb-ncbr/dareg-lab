/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * OpenAPI spec version: 0.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

export type ApiV1UsersListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1SchemasListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1ReservationRetrieveParams = {
/**
 * ISO formated FROM timestamp
 */
date_from: string;
/**
 * ISO formated TO timestamp
 */
date_to: string;
};

export type ApiV1ProjectsListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1ProfileListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1InstrumentListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1GroupsListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1FacilitiesListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1ExperimentsListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiV1DatasetsListParams = {
/**
 * A page number within the paginated result set.
 */
page?: number;
};

export type ApiSchemaRetrieve200Four = {[key: string]: unknown};

export type ApiSchemaRetrieve200Three = {[key: string]: unknown};

export type ApiSchemaRetrieve200Two = {[key: string]: unknown};

export type ApiSchemaRetrieve200One = {[key: string]: unknown};

export type ApiSchemaRetrieveLang = typeof ApiSchemaRetrieveLang[keyof typeof ApiSchemaRetrieveLang];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiSchemaRetrieveLang = {
  af: 'af',
  ar: 'ar',
  'ar-dz': 'ar-dz',
  ast: 'ast',
  az: 'az',
  be: 'be',
  bg: 'bg',
  bn: 'bn',
  br: 'br',
  bs: 'bs',
  ca: 'ca',
  ckb: 'ckb',
  cs: 'cs',
  cy: 'cy',
  da: 'da',
  de: 'de',
  dsb: 'dsb',
  el: 'el',
  en: 'en',
  'en-au': 'en-au',
  'en-gb': 'en-gb',
  eo: 'eo',
  es: 'es',
  'es-ar': 'es-ar',
  'es-co': 'es-co',
  'es-mx': 'es-mx',
  'es-ni': 'es-ni',
  'es-ve': 'es-ve',
  et: 'et',
  eu: 'eu',
  fa: 'fa',
  fi: 'fi',
  fr: 'fr',
  fy: 'fy',
  ga: 'ga',
  gd: 'gd',
  gl: 'gl',
  he: 'he',
  hi: 'hi',
  hr: 'hr',
  hsb: 'hsb',
  hu: 'hu',
  hy: 'hy',
  ia: 'ia',
  id: 'id',
  ig: 'ig',
  io: 'io',
  is: 'is',
  it: 'it',
  ja: 'ja',
  ka: 'ka',
  kab: 'kab',
  kk: 'kk',
  km: 'km',
  kn: 'kn',
  ko: 'ko',
  ky: 'ky',
  lb: 'lb',
  lt: 'lt',
  lv: 'lv',
  mk: 'mk',
  ml: 'ml',
  mn: 'mn',
  mr: 'mr',
  ms: 'ms',
  my: 'my',
  nb: 'nb',
  ne: 'ne',
  nl: 'nl',
  nn: 'nn',
  os: 'os',
  pa: 'pa',
  pl: 'pl',
  pt: 'pt',
  'pt-br': 'pt-br',
  ro: 'ro',
  ru: 'ru',
  sk: 'sk',
  sl: 'sl',
  sq: 'sq',
  sr: 'sr',
  'sr-latn': 'sr-latn',
  sv: 'sv',
  sw: 'sw',
  ta: 'ta',
  te: 'te',
  tg: 'tg',
  th: 'th',
  tk: 'tk',
  tr: 'tr',
  tt: 'tt',
  udm: 'udm',
  uk: 'uk',
  ur: 'ur',
  uz: 'uz',
  vi: 'vi',
  'zh-hans': 'zh-hans',
  'zh-hant': 'zh-hant',
} as const;

export type ApiSchemaRetrieveFormat = typeof ApiSchemaRetrieveFormat[keyof typeof ApiSchemaRetrieveFormat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ApiSchemaRetrieveFormat = {
  json: 'json',
  yaml: 'yaml',
} as const;

export type ApiSchemaRetrieveParams = {
format?: ApiSchemaRetrieveFormat;
lang?: ApiSchemaRetrieveLang;
};

export interface UserSerializerMinimal {
  readonly id: number;
  readonly full_name: string;
}

export interface User {
  readonly id: number;
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @maxLength 150
   * @pattern ^[\w.@+-]+$
   */
  username: string;
  /** @maxLength 254 */
  email?: string;
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[];
  /** @maxLength 150 */
  first_name?: string;
  /** @maxLength 150 */
  last_name?: string;
  readonly name: string;
}

/**
 * * `new` - NEW
* `finished` - FINISHED
 */
export type Status464Enum = typeof Status464Enum[keyof typeof Status464Enum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Status464Enum = {
  new: 'new',
  finished: 'finished',
} as const;

export interface Schema {
  readonly id: string;
  readonly created: string;
  readonly modified: string;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  version?: number;
  /** @maxLength 200 */
  name: string;
  /**
   * @maxLength 500
   * @nullable
   */
  description?: string | null;
  schema?: unknown;
  uischema?: unknown;
  /** @nullable */
  readonly created_by: number | null;
  /** @nullable */
  readonly modified_by: number | null;
}

export interface Reservation {
  id: string;
  name: string;
  from_date: string;
  to_date: string;
  user: string;
  description: string;
  project_id: string;
  /** @nullable */
  readonly dataset_status: string | null;
}

export interface ProjectResponse {
  id: string;
  name: string;
  readonly created_by: UserSerializerMinimal;
  readonly perms: string;
  readonly shares: string;
  readonly facility: FacilitySerializerMinimal;
  readonly default_dataset_schema: BaseModel;
  readonly project_schema: BaseModel;
  readonly created: string;
  readonly modified: string;
  /** @maxLength 500 */
  description: string;
  /** @maxLength 200 */
  onedata_space_id?: string;
  /** @nullable */
  modified_by?: number | null;
}

export interface Project {
  readonly id: string;
  readonly created: string;
  readonly modified: string;
  /** @maxLength 200 */
  name: string;
  /** @maxLength 500 */
  description: string;
  /** @maxLength 200 */
  onedata_space_id?: string;
  /** @nullable */
  readonly created_by: number | null;
  /** @nullable */
  readonly modified_by: number | null;
  facility: string;
  /** @nullable */
  default_dataset_schema?: string | null;
}

export interface Profile {
  readonly created: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  default_data_rows?: DefaultDataRowsEnum;
  readonly any_datasets: string;
  readonly any_facilities: string;
  readonly any_projects: string;
  readonly app_version: string;
  readonly avatar: string;
  readonly last_login: string;
  default_theme?: DefaultThemeEnum;
  default_lang?: DefaultLangEnum;
}

export interface PatchedUser {
  readonly id?: number;
  /**
   * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
   * @maxLength 150
   * @pattern ^[\w.@+-]+$
   */
  username?: string;
  /** @maxLength 254 */
  email?: string;
  /** The groups this user belongs to. A user will get all permissions granted to each of their groups. */
  groups?: number[];
  /** @maxLength 150 */
  first_name?: string;
  /** @maxLength 150 */
  last_name?: string;
  readonly name?: string;
}

export interface PatchedSchema {
  readonly id?: string;
  readonly created?: string;
  readonly modified?: string;
  /**
   * @minimum 0
   * @maximum 2147483647
   */
  version?: number;
  /** @maxLength 200 */
  name?: string;
  /**
   * @maxLength 500
   * @nullable
   */
  description?: string | null;
  schema?: unknown;
  uischema?: unknown;
  /** @nullable */
  readonly created_by?: number | null;
  /** @nullable */
  readonly modified_by?: number | null;
}

export interface PatchedProject {
  readonly id?: string;
  readonly created?: string;
  readonly modified?: string;
  /** @maxLength 200 */
  name?: string;
  /** @maxLength 500 */
  description?: string;
  /** @maxLength 200 */
  onedata_space_id?: string;
  /** @nullable */
  readonly created_by?: number | null;
  /** @nullable */
  readonly modified_by?: number | null;
  facility?: string;
  /** @nullable */
  default_dataset_schema?: string | null;
}

export interface PatchedProfile {
  readonly created?: string;
  /**
   * @minimum -2147483648
   * @maximum 2147483647
   */
  default_data_rows?: DefaultDataRowsEnum;
  readonly any_datasets?: string;
  readonly any_facilities?: string;
  readonly any_projects?: string;
  readonly app_version?: string;
  readonly avatar?: string;
  readonly last_login?: string;
  default_theme?: DefaultThemeEnum;
  default_lang?: DefaultLangEnum;
}

export interface PatchedInstrument {
  readonly id?: string;
  /** @maxLength 200 */
  name?: string;
  /** @maxLength 500 */
  support?: string;
  /** @maxLength 500 */
  contact?: string;
  /** @maxLength 500 */
  method?: string;
  readonly facility?: FacilitySerializerMinimal;
  /** @maxLength 1024 */
  default_data_dir?: string;
}

export interface PatchedGroup {
  /** @maxLength 150 */
  name?: string;
}

export interface PatchedFacility {
  readonly id?: string;
  readonly perms?: string;
  readonly shares?: string;
  readonly created?: string;
  readonly modified?: string;
  /** @maxLength 200 */
  name?: string;
  /** @maxLength 20 */
  abbreviation?: string;
  /** @maxLength 200 */
  web?: string;
  /** @maxLength 200 */
  email?: string;
  /** @maxLength 200 */
  logo?: string;
  /** @maxLength 512 */
  onedata_token?: string;
  /** @maxLength 200 */
  onedata_provider_url?: string;
  /** @nullable */
  readonly created_by?: number | null;
  /** @nullable */
  readonly modified_by?: number | null;
}

export interface PatchedExperiment {
  readonly id?: string;
  readonly created?: string;
  readonly modified?: string;
  /** @maxLength 200 */
  name?: string;
  /** @nullable */
  start_time?: string | null;
  /** @nullable */
  end_time?: string | null;
  /** @maxLength 500 */
  note?: string;
  status?: ExperimentStatusEnum;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_file_id?: string | null;
  /** @nullable */
  readonly created_by?: number | null;
  /** @nullable */
  readonly modified_by?: number | null;
  dataset?: string;
}

export interface PatchedDataset {
  readonly id?: string;
  readonly created?: string;
  readonly modified?: string;
  /** @maxLength 200 */
  name?: string;
  /** @maxLength 500 */
  description?: string;
  metadata?: unknown;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_file_id?: string | null;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_share_id?: string | null;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_dataset_id?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  doi?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  reservationId?: string | null;
  status?: Status464Enum;
  /** @nullable */
  readonly created_by?: number | null;
  /** @nullable */
  readonly modified_by?: number | null;
  project?: string;
  /** @nullable */
  schema?: string | null;
  tags?: string[];
}

export interface PaginatedUserList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: User[];
}

export interface PaginatedSchemaList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Schema[];
}

export interface PaginatedProjectResponseList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: ProjectResponse[];
}

export interface PaginatedProfileList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Profile[];
}

export interface PaginatedInstrumentList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Instrument[];
}

export interface PaginatedGroupList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Group[];
}

export interface PaginatedFacilityList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Facility[];
}

export interface PaginatedExperimentList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: Experiment[];
}

export interface PaginatedDatasetResponseList {
  count?: number;
  /** @nullable */
  next?: string | null;
  /** @nullable */
  previous?: string | null;
  results?: DatasetResponse[];
}

export interface Instrument {
  readonly id: string;
  /** @maxLength 200 */
  name: string;
  /** @maxLength 500 */
  support: string;
  /** @maxLength 500 */
  contact: string;
  /** @maxLength 500 */
  method: string;
  readonly facility: FacilitySerializerMinimal;
  /** @maxLength 1024 */
  default_data_dir?: string;
}

export interface Group {
  /** @maxLength 150 */
  name: string;
}

export interface FacilitySerializerMinimal {
  readonly id: string;
  /** @maxLength 200 */
  name: string;
  /** @maxLength 20 */
  abbreviation: string;
  /** @maxLength 200 */
  email?: string;
  /** @maxLength 200 */
  web?: string;
  /** @maxLength 200 */
  logo?: string;
}

export interface Facility {
  readonly id: string;
  readonly perms: string;
  readonly shares: string;
  readonly created: string;
  readonly modified: string;
  /** @maxLength 200 */
  name: string;
  /** @maxLength 20 */
  abbreviation: string;
  /** @maxLength 200 */
  web?: string;
  /** @maxLength 200 */
  email?: string;
  /** @maxLength 200 */
  logo?: string;
  /** @maxLength 512 */
  onedata_token?: string;
  /** @maxLength 200 */
  onedata_provider_url?: string;
  /** @nullable */
  readonly created_by: number | null;
  /** @nullable */
  readonly modified_by: number | null;
}

/**
 * * `new` - NEW
* `prepared` - PREPARED
* `running` - RUNNING
* `synchronizing` - SYNCHRONIZING
* `success` - SUCCESS
* `failure` - FAILURE
* `discarded` - DISCARDED
 */
export type ExperimentStatusEnum = typeof ExperimentStatusEnum[keyof typeof ExperimentStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ExperimentStatusEnum = {
  new: 'new',
  prepared: 'prepared',
  running: 'running',
  synchronizing: 'synchronizing',
  success: 'success',
  failure: 'failure',
  discarded: 'discarded',
} as const;

export interface Experiment {
  readonly id: string;
  readonly created: string;
  readonly modified: string;
  /** @maxLength 200 */
  name?: string;
  /** @nullable */
  start_time?: string | null;
  /** @nullable */
  end_time?: string | null;
  /** @maxLength 500 */
  note?: string;
  status?: ExperimentStatusEnum;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_file_id?: string | null;
  /** @nullable */
  readonly created_by: number | null;
  /** @nullable */
  readonly modified_by: number | null;
  dataset: string;
}

/**
 * * `dark` - Dark
* `light` - Light
* `system` - System
 */
export type DefaultThemeEnum = typeof DefaultThemeEnum[keyof typeof DefaultThemeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultThemeEnum = {
  dark: 'dark',
  light: 'light',
  system: 'system',
} as const;

/**
 * * `cs-CZ` - Czech
* `en-US` - English
 */
export type DefaultLangEnum = typeof DefaultLangEnum[keyof typeof DefaultLangEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultLangEnum = {
  'cs-CZ': 'cs-CZ',
  'en-US': 'en-US',
} as const;

/**
 * * `25` - Value1
* `50` - Value2
* `100` - Value3
* `250` - Value4
 */
export type DefaultDataRowsEnum = typeof DefaultDataRowsEnum[keyof typeof DefaultDataRowsEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const DefaultDataRowsEnum = {
  NUMBER_25: 25,
  NUMBER_50: 50,
  NUMBER_100: 100,
  NUMBER_250: 250,
} as const;

export interface DatasetResponse {
  id: string;
  name: string;
  readonly created_by: UserSerializerMinimal;
  readonly perms: string;
  readonly shares: string;
  readonly project: BaseModel;
  readonly experiments: readonly Experiment[];
  readonly dataset_schema: BaseModel;
  readonly modified_by: UserSerializerMinimal;
  readonly onedata_visit_id: string;
  readonly created: string;
  readonly modified: string;
  /** @maxLength 500 */
  description: string;
  metadata?: unknown;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_file_id?: string | null;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_share_id?: string | null;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_dataset_id?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  doi?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  reservationId?: string | null;
  status?: Status464Enum;
  /** @nullable */
  schema?: string | null;
  tags?: string[];
}

export interface Dataset {
  readonly id: string;
  readonly created: string;
  readonly modified: string;
  /** @maxLength 200 */
  name: string;
  /** @maxLength 500 */
  description: string;
  metadata?: unknown;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_file_id?: string | null;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_share_id?: string | null;
  /**
   * @maxLength 512
   * @nullable
   */
  onedata_dataset_id?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  doi?: string | null;
  /**
   * @maxLength 50
   * @nullable
   */
  reservationId?: string | null;
  status?: Status464Enum;
  /** @nullable */
  readonly created_by: number | null;
  /** @nullable */
  readonly modified_by: number | null;
  project: string;
  /** @nullable */
  schema?: string | null;
  tags?: string[];
}

export interface BaseModel {
  name: string;
  id: string;
  readonly created_by: UserSerializerMinimal;
}





/**
 * OpenApi3 schema for this API. Format can be selected via content negotiation.

- YAML: application/vnd.oai.openapi
- JSON: application/vnd.oai.openapi+json
 */
export const apiSchemaRetrieve = (
    params?: ApiSchemaRetrieveParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ApiSchemaRetrieve200One | ApiSchemaRetrieve200Two | ApiSchemaRetrieve200Three | ApiSchemaRetrieve200Four>> => {
    
    
    return axios.default.get(
      `/api/schema/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiSchemaRetrieveQueryKey = (params?: ApiSchemaRetrieveParams,) => {
    return [`/api/schema/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiSchemaRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = AxiosError<unknown>>(params?: ApiSchemaRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiSchemaRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiSchemaRetrieve>>> = ({ signal }) => apiSchemaRetrieve(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiSchemaRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiSchemaRetrieve>>>
export type ApiSchemaRetrieveQueryError = AxiosError<unknown>


export function useApiSchemaRetrieve<TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiSchemaRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiSchemaRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiSchemaRetrieve<TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = AxiosError<unknown>>(
 params?: ApiSchemaRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiSchemaRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiSchemaRetrieve<TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = AxiosError<unknown>>(
 params?: ApiSchemaRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiSchemaRetrieve<TData = Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError = AxiosError<unknown>>(
 params?: ApiSchemaRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiSchemaRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiSchemaRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiTokenLoginCreate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/token/login/`,undefined,options
    );
  }



export const getApiTokenLoginCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiTokenLoginCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiTokenLoginCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenLoginCreate>>, void> = () => {
          

          return  apiTokenLoginCreate(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type ApiTokenLoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenLoginCreate>>>
    
    export type ApiTokenLoginCreateMutationError = AxiosError<unknown>

    export const useApiTokenLoginCreate = <TData = Awaited<ReturnType<typeof apiTokenLoginCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getApiTokenLoginCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiTokenLogoutCreate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/token/logout/`,undefined,options
    );
  }



export const getApiTokenLogoutCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiTokenLogoutCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiTokenLogoutCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenLogoutCreate>>, void> = () => {
          

          return  apiTokenLogoutCreate(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type ApiTokenLogoutCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenLogoutCreate>>>
    
    export type ApiTokenLogoutCreateMutationError = AxiosError<unknown>

    export const useApiTokenLogoutCreate = <TData = Awaited<ReturnType<typeof apiTokenLogoutCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getApiTokenLogoutCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Log the user out of all sessions
I.E. deletes all auth tokens for the user
 */
export const apiTokenLogoutallCreate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/token/logoutall/`,undefined,options
    );
  }



export const getApiTokenLogoutallCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiTokenLogoutallCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiTokenLogoutallCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiTokenLogoutallCreate>>, void> = () => {
          

          return  apiTokenLogoutallCreate(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type ApiTokenLogoutallCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiTokenLogoutallCreate>>>
    
    export type ApiTokenLogoutallCreateMutationError = AxiosError<unknown>

    export const useApiTokenLogoutallCreate = <TData = Awaited<ReturnType<typeof apiTokenLogoutallCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getApiTokenLogoutallCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsList = (
    params?: ApiV1DatasetsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedDatasetResponseList>> => {
    
    
    return axios.default.get(
      `/api/v1/datasets/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1DatasetsListQueryKey = (params?: ApiV1DatasetsListParams,) => {
    return [`/api/v1/datasets/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1DatasetsListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsList>>, TError = AxiosError<unknown>>(params?: ApiV1DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1DatasetsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1DatasetsList>>> = ({ signal }) => apiV1DatasetsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1DatasetsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsList>>>
export type ApiV1DatasetsListQueryError = AxiosError<unknown>


export function useApiV1DatasetsList<TData = Awaited<ReturnType<typeof apiV1DatasetsList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1DatasetsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1DatasetsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1DatasetsList<TData = Awaited<ReturnType<typeof apiV1DatasetsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1DatasetsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1DatasetsList<TData = Awaited<ReturnType<typeof apiV1DatasetsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1DatasetsList<TData = Awaited<ReturnType<typeof apiV1DatasetsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1DatasetsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1DatasetsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsCreate = (
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/datasets/`,
      dataset,options
    );
  }



export const getApiV1DatasetsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsCreate>>, {data: NonReadonly<Dataset>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1DatasetsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>}

    export type ApiV1DatasetsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsCreate>>>
    export type ApiV1DatasetsCreateMutationBody = NonReadonly<Dataset>
    export type ApiV1DatasetsCreateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsCreate = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.get(
      `/api/v1/datasets/${id}/`,options
    );
  }


export const getApiV1DatasetsRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/datasets/${id}/`] as const;
    }

    
export const getApiV1DatasetsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1DatasetsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>> = ({ signal }) => apiV1DatasetsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1DatasetsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>>
export type ApiV1DatasetsRetrieveQueryError = AxiosError<unknown>


export function useApiV1DatasetsRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1DatasetsRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1DatasetsRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1DatasetsRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1DatasetsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsUpdate = (
    id: string,
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.put(
      `/api/v1/datasets/${id}/`,
      dataset,options
    );
  }



export const getApiV1DatasetsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsUpdate>>, {id: string;data: NonReadonly<Dataset>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1DatasetsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Dataset>}, TContext>}

    export type ApiV1DatasetsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsUpdate>>>
    export type ApiV1DatasetsUpdateMutationBody = NonReadonly<Dataset>
    export type ApiV1DatasetsUpdateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsUpdate = <TData = Awaited<ReturnType<typeof apiV1DatasetsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsPartialUpdate = (
    id: string,
    patchedDataset: NonReadonly<PatchedDataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.patch(
      `/api/v1/datasets/${id}/`,
      patchedDataset,options
    );
  }



export const getApiV1DatasetsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedDataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsPartialUpdate>>, {id: string;data: NonReadonly<PatchedDataset>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1DatasetsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedDataset>}, TContext>}

    export type ApiV1DatasetsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsPartialUpdate>>>
    export type ApiV1DatasetsPartialUpdateMutationBody = NonReadonly<PatchedDataset>
    export type ApiV1DatasetsPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1DatasetsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedDataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedDataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/datasets/${id}/`,options
    );
  }



export const getApiV1DatasetsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1DatasetsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1DatasetsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsDestroy>>>
    
    export type ApiV1DatasetsDestroyMutationError = AxiosError<unknown>

    export const useApiV1DatasetsDestroy = <TData = Awaited<ReturnType<typeof apiV1DatasetsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsGetByReservationIdRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.get(
      `/api/v1/datasets/${id}/get_by_reservation_id/`,options
    );
  }


export const getApiV1DatasetsGetByReservationIdRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/datasets/${id}/get_by_reservation_id/`] as const;
    }

    
export const getApiV1DatasetsGetByReservationIdRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1DatasetsGetByReservationIdRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>> = ({ signal }) => apiV1DatasetsGetByReservationIdRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1DatasetsGetByReservationIdRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>>
export type ApiV1DatasetsGetByReservationIdRetrieveQueryError = AxiosError<unknown>


export function useApiV1DatasetsGetByReservationIdRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1DatasetsGetByReservationIdRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1DatasetsGetByReservationIdRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1DatasetsGetByReservationIdRetrieve<TData = Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1DatasetsGetByReservationIdRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1DatasetsGetByReservationIdRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsCreateDatasetCreate = (
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/datasets/create_dataset/`,
      dataset,options
    );
  }



export const getApiV1DatasetsCreateDatasetCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreateDatasetCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsCreateDatasetCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsCreateDatasetCreate>>, {data: NonReadonly<Dataset>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1DatasetsCreateDatasetCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>}

    export type ApiV1DatasetsCreateDatasetCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsCreateDatasetCreate>>>
    export type ApiV1DatasetsCreateDatasetCreateMutationBody = NonReadonly<Dataset>
    export type ApiV1DatasetsCreateDatasetCreateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsCreateDatasetCreate = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreateDatasetCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsCreateDatasetCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsCreateOnedataFolderCreate = (
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/datasets/create_onedata_folder/`,
      dataset,options
    );
  }



export const getApiV1DatasetsCreateOnedataFolderCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreateOnedataFolderCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsCreateOnedataFolderCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsCreateOnedataFolderCreate>>, {data: NonReadonly<Dataset>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1DatasetsCreateOnedataFolderCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>}

    export type ApiV1DatasetsCreateOnedataFolderCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsCreateOnedataFolderCreate>>>
    export type ApiV1DatasetsCreateOnedataFolderCreateMutationBody = NonReadonly<Dataset>
    export type ApiV1DatasetsCreateOnedataFolderCreateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsCreateOnedataFolderCreate = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreateOnedataFolderCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsCreateOnedataFolderCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsCreatePublicShareCreate = (
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/datasets/create_public_share/`,
      dataset,options
    );
  }



export const getApiV1DatasetsCreatePublicShareCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreatePublicShareCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsCreatePublicShareCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsCreatePublicShareCreate>>, {data: NonReadonly<Dataset>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1DatasetsCreatePublicShareCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>}

    export type ApiV1DatasetsCreatePublicShareCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsCreatePublicShareCreate>>>
    export type ApiV1DatasetsCreatePublicShareCreateMutationBody = NonReadonly<Dataset>
    export type ApiV1DatasetsCreatePublicShareCreateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsCreatePublicShareCreate = <TData = Awaited<ReturnType<typeof apiV1DatasetsCreatePublicShareCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsCreatePublicShareCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows dataset to be viewed or edited.
 */
export const apiV1DatasetsShadowCreate = (
    dataset: NonReadonly<Dataset>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DatasetResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/datasets/shadow/`,
      dataset,options
    );
  }



export const getApiV1DatasetsShadowCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1DatasetsShadowCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1DatasetsShadowCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1DatasetsShadowCreate>>, {data: NonReadonly<Dataset>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1DatasetsShadowCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>}

    export type ApiV1DatasetsShadowCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1DatasetsShadowCreate>>>
    export type ApiV1DatasetsShadowCreateMutationBody = NonReadonly<Dataset>
    export type ApiV1DatasetsShadowCreateMutationError = AxiosError<unknown>

    export const useApiV1DatasetsShadowCreate = <TData = Awaited<ReturnType<typeof apiV1DatasetsShadowCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Dataset>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Dataset>},
        TContext
      > => {

      const mutationOptions = getApiV1DatasetsShadowCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows experiments to be viewed or edited.
 */
export const apiV1ExperimentsList = (
    params?: ApiV1ExperimentsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedExperimentList>> => {
    
    
    return axios.default.get(
      `/api/v1/experiments/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1ExperimentsListQueryKey = (params?: ApiV1ExperimentsListParams,) => {
    return [`/api/v1/experiments/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1ExperimentsListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError = AxiosError<unknown>>(params?: ApiV1ExperimentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ExperimentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ExperimentsList>>> = ({ signal }) => apiV1ExperimentsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ExperimentsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ExperimentsList>>>
export type ApiV1ExperimentsListQueryError = AxiosError<unknown>


export function useApiV1ExperimentsList<TData = Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1ExperimentsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ExperimentsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ExperimentsList<TData = Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ExperimentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ExperimentsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ExperimentsList<TData = Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ExperimentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ExperimentsList<TData = Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ExperimentsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ExperimentsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows experiments to be viewed or edited.
 */
export const apiV1ExperimentsCreate = (
    experiment: NonReadonly<Experiment>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Experiment>> => {
    
    
    return axios.default.post(
      `/api/v1/experiments/`,
      experiment,options
    );
  }



export const getApiV1ExperimentsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ExperimentsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Experiment>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ExperimentsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ExperimentsCreate>>, {data: NonReadonly<Experiment>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1ExperimentsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Experiment>}, TContext>}

    export type ApiV1ExperimentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ExperimentsCreate>>>
    export type ApiV1ExperimentsCreateMutationBody = NonReadonly<Experiment>
    export type ApiV1ExperimentsCreateMutationError = AxiosError<unknown>

    export const useApiV1ExperimentsCreate = <TData = Awaited<ReturnType<typeof apiV1ExperimentsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Experiment>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Experiment>},
        TContext
      > => {

      const mutationOptions = getApiV1ExperimentsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows experiments to be viewed or edited.
 */
export const apiV1ExperimentsRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Experiment>> => {
    
    
    return axios.default.get(
      `/api/v1/experiments/${id}/`,options
    );
  }


export const getApiV1ExperimentsRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/experiments/${id}/`] as const;
    }

    
export const getApiV1ExperimentsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ExperimentsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>> = ({ signal }) => apiV1ExperimentsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ExperimentsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>>
export type ApiV1ExperimentsRetrieveQueryError = AxiosError<unknown>


export function useApiV1ExperimentsRetrieve<TData = Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ExperimentsRetrieve<TData = Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ExperimentsRetrieve<TData = Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ExperimentsRetrieve<TData = Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ExperimentsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ExperimentsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows experiments to be viewed or edited.
 */
export const apiV1ExperimentsUpdate = (
    id: string,
    experiment: NonReadonly<Experiment>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Experiment>> => {
    
    
    return axios.default.put(
      `/api/v1/experiments/${id}/`,
      experiment,options
    );
  }



export const getApiV1ExperimentsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ExperimentsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Experiment>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ExperimentsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ExperimentsUpdate>>, {id: string;data: NonReadonly<Experiment>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1ExperimentsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Experiment>}, TContext>}

    export type ApiV1ExperimentsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ExperimentsUpdate>>>
    export type ApiV1ExperimentsUpdateMutationBody = NonReadonly<Experiment>
    export type ApiV1ExperimentsUpdateMutationError = AxiosError<unknown>

    export const useApiV1ExperimentsUpdate = <TData = Awaited<ReturnType<typeof apiV1ExperimentsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Experiment>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Experiment>},
        TContext
      > => {

      const mutationOptions = getApiV1ExperimentsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows experiments to be viewed or edited.
 */
export const apiV1ExperimentsPartialUpdate = (
    id: string,
    patchedExperiment: NonReadonly<PatchedExperiment>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Experiment>> => {
    
    
    return axios.default.patch(
      `/api/v1/experiments/${id}/`,
      patchedExperiment,options
    );
  }



export const getApiV1ExperimentsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ExperimentsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedExperiment>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ExperimentsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ExperimentsPartialUpdate>>, {id: string;data: NonReadonly<PatchedExperiment>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1ExperimentsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedExperiment>}, TContext>}

    export type ApiV1ExperimentsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ExperimentsPartialUpdate>>>
    export type ApiV1ExperimentsPartialUpdateMutationBody = NonReadonly<PatchedExperiment>
    export type ApiV1ExperimentsPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1ExperimentsPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1ExperimentsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedExperiment>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedExperiment>},
        TContext
      > => {

      const mutationOptions = getApiV1ExperimentsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows experiments to be viewed or edited.
 */
export const apiV1ExperimentsDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/experiments/${id}/`,options
    );
  }



export const getApiV1ExperimentsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ExperimentsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ExperimentsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ExperimentsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1ExperimentsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1ExperimentsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ExperimentsDestroy>>>
    
    export type ApiV1ExperimentsDestroyMutationError = AxiosError<unknown>

    export const useApiV1ExperimentsDestroy = <TData = Awaited<ReturnType<typeof apiV1ExperimentsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1ExperimentsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows facilities to be viewed or edited.
 */
export const apiV1FacilitiesList = (
    params?: ApiV1FacilitiesListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedFacilityList>> => {
    
    
    return axios.default.get(
      `/api/v1/facilities/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1FacilitiesListQueryKey = (params?: ApiV1FacilitiesListParams,) => {
    return [`/api/v1/facilities/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1FacilitiesListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError = AxiosError<unknown>>(params?: ApiV1FacilitiesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1FacilitiesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1FacilitiesList>>> = ({ signal }) => apiV1FacilitiesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1FacilitiesListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1FacilitiesList>>>
export type ApiV1FacilitiesListQueryError = AxiosError<unknown>


export function useApiV1FacilitiesList<TData = Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1FacilitiesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1FacilitiesList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1FacilitiesList<TData = Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError = AxiosError<unknown>>(
 params?: ApiV1FacilitiesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1FacilitiesList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1FacilitiesList<TData = Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError = AxiosError<unknown>>(
 params?: ApiV1FacilitiesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1FacilitiesList<TData = Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError = AxiosError<unknown>>(
 params?: ApiV1FacilitiesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1FacilitiesListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows facilities to be viewed or edited.
 */
export const apiV1FacilitiesCreate = (
    facility: NonReadonly<Facility>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Facility>> => {
    
    
    return axios.default.post(
      `/api/v1/facilities/`,
      facility,options
    );
  }



export const getApiV1FacilitiesCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1FacilitiesCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Facility>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1FacilitiesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1FacilitiesCreate>>, {data: NonReadonly<Facility>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1FacilitiesCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Facility>}, TContext>}

    export type ApiV1FacilitiesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1FacilitiesCreate>>>
    export type ApiV1FacilitiesCreateMutationBody = NonReadonly<Facility>
    export type ApiV1FacilitiesCreateMutationError = AxiosError<unknown>

    export const useApiV1FacilitiesCreate = <TData = Awaited<ReturnType<typeof apiV1FacilitiesCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Facility>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Facility>},
        TContext
      > => {

      const mutationOptions = getApiV1FacilitiesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows facilities to be viewed or edited.
 */
export const apiV1FacilitiesRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Facility>> => {
    
    
    return axios.default.get(
      `/api/v1/facilities/${id}/`,options
    );
  }


export const getApiV1FacilitiesRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/facilities/${id}/`] as const;
    }

    
export const getApiV1FacilitiesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1FacilitiesRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>> = ({ signal }) => apiV1FacilitiesRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1FacilitiesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>>
export type ApiV1FacilitiesRetrieveQueryError = AxiosError<unknown>


export function useApiV1FacilitiesRetrieve<TData = Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1FacilitiesRetrieve<TData = Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1FacilitiesRetrieve<TData = Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1FacilitiesRetrieve<TData = Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1FacilitiesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1FacilitiesRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows facilities to be viewed or edited.
 */
export const apiV1FacilitiesUpdate = (
    id: string,
    facility: NonReadonly<Facility>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Facility>> => {
    
    
    return axios.default.put(
      `/api/v1/facilities/${id}/`,
      facility,options
    );
  }



export const getApiV1FacilitiesUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1FacilitiesUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Facility>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1FacilitiesUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1FacilitiesUpdate>>, {id: string;data: NonReadonly<Facility>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1FacilitiesUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Facility>}, TContext>}

    export type ApiV1FacilitiesUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1FacilitiesUpdate>>>
    export type ApiV1FacilitiesUpdateMutationBody = NonReadonly<Facility>
    export type ApiV1FacilitiesUpdateMutationError = AxiosError<unknown>

    export const useApiV1FacilitiesUpdate = <TData = Awaited<ReturnType<typeof apiV1FacilitiesUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Facility>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Facility>},
        TContext
      > => {

      const mutationOptions = getApiV1FacilitiesUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows facilities to be viewed or edited.
 */
export const apiV1FacilitiesPartialUpdate = (
    id: string,
    patchedFacility: NonReadonly<PatchedFacility>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Facility>> => {
    
    
    return axios.default.patch(
      `/api/v1/facilities/${id}/`,
      patchedFacility,options
    );
  }



export const getApiV1FacilitiesPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1FacilitiesPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedFacility>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1FacilitiesPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1FacilitiesPartialUpdate>>, {id: string;data: NonReadonly<PatchedFacility>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1FacilitiesPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedFacility>}, TContext>}

    export type ApiV1FacilitiesPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1FacilitiesPartialUpdate>>>
    export type ApiV1FacilitiesPartialUpdateMutationBody = NonReadonly<PatchedFacility>
    export type ApiV1FacilitiesPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1FacilitiesPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1FacilitiesPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedFacility>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedFacility>},
        TContext
      > => {

      const mutationOptions = getApiV1FacilitiesPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows facilities to be viewed or edited.
 */
export const apiV1FacilitiesDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/facilities/${id}/`,options
    );
  }



export const getApiV1FacilitiesDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1FacilitiesDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1FacilitiesDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1FacilitiesDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1FacilitiesDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1FacilitiesDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1FacilitiesDestroy>>>
    
    export type ApiV1FacilitiesDestroyMutationError = AxiosError<unknown>

    export const useApiV1FacilitiesDestroy = <TData = Awaited<ReturnType<typeof apiV1FacilitiesDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1FacilitiesDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows groups to be viewed or edited.
 */
export const apiV1GroupsList = (
    params?: ApiV1GroupsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedGroupList>> => {
    
    
    return axios.default.get(
      `/api/v1/groups/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1GroupsListQueryKey = (params?: ApiV1GroupsListParams,) => {
    return [`/api/v1/groups/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1GroupsListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1GroupsList>>, TError = AxiosError<unknown>>(params?: ApiV1GroupsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1GroupsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1GroupsList>>> = ({ signal }) => apiV1GroupsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1GroupsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1GroupsList>>>
export type ApiV1GroupsListQueryError = AxiosError<unknown>


export function useApiV1GroupsList<TData = Awaited<ReturnType<typeof apiV1GroupsList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1GroupsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1GroupsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1GroupsList<TData = Awaited<ReturnType<typeof apiV1GroupsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1GroupsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1GroupsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1GroupsList<TData = Awaited<ReturnType<typeof apiV1GroupsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1GroupsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1GroupsList<TData = Awaited<ReturnType<typeof apiV1GroupsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1GroupsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1GroupsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows groups to be viewed or edited.
 */
export const apiV1GroupsCreate = (
    group: Group, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group>> => {
    
    
    return axios.default.post(
      `/api/v1/groups/`,
      group,options
    );
  }



export const getApiV1GroupsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1GroupsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Group}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1GroupsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1GroupsCreate>>, {data: Group}> = (props) => {
          const {data} = props ?? {};

          return  apiV1GroupsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: Group}, TContext>}

    export type ApiV1GroupsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1GroupsCreate>>>
    export type ApiV1GroupsCreateMutationBody = Group
    export type ApiV1GroupsCreateMutationError = AxiosError<unknown>

    export const useApiV1GroupsCreate = <TData = Awaited<ReturnType<typeof apiV1GroupsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: Group}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: Group},
        TContext
      > => {

      const mutationOptions = getApiV1GroupsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows groups to be viewed or edited.
 */
export const apiV1GroupsRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group>> => {
    
    
    return axios.default.get(
      `/api/v1/groups/${id}/`,options
    );
  }


export const getApiV1GroupsRetrieveQueryKey = (id: number,) => {
    return [`/api/v1/groups/${id}/`] as const;
    }

    
export const getApiV1GroupsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1GroupsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>> = ({ signal }) => apiV1GroupsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1GroupsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>>
export type ApiV1GroupsRetrieveQueryError = AxiosError<unknown>


export function useApiV1GroupsRetrieve<TData = Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1GroupsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1GroupsRetrieve<TData = Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1GroupsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1GroupsRetrieve<TData = Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1GroupsRetrieve<TData = Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1GroupsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1GroupsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows groups to be viewed or edited.
 */
export const apiV1GroupsUpdate = (
    id: number,
    group: Group, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group>> => {
    
    
    return axios.default.put(
      `/api/v1/groups/${id}/`,
      group,options
    );
  }



export const getApiV1GroupsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1GroupsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Group}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1GroupsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1GroupsUpdate>>, {id: number;data: Group}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1GroupsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: Group}, TContext>}

    export type ApiV1GroupsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1GroupsUpdate>>>
    export type ApiV1GroupsUpdateMutationBody = Group
    export type ApiV1GroupsUpdateMutationError = AxiosError<unknown>

    export const useApiV1GroupsUpdate = <TData = Awaited<ReturnType<typeof apiV1GroupsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: Group}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: Group},
        TContext
      > => {

      const mutationOptions = getApiV1GroupsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows groups to be viewed or edited.
 */
export const apiV1GroupsPartialUpdate = (
    id: number,
    patchedGroup: PatchedGroup, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Group>> => {
    
    
    return axios.default.patch(
      `/api/v1/groups/${id}/`,
      patchedGroup,options
    );
  }



export const getApiV1GroupsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1GroupsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PatchedGroup}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1GroupsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1GroupsPartialUpdate>>, {id: number;data: PatchedGroup}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1GroupsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: PatchedGroup}, TContext>}

    export type ApiV1GroupsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1GroupsPartialUpdate>>>
    export type ApiV1GroupsPartialUpdateMutationBody = PatchedGroup
    export type ApiV1GroupsPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1GroupsPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1GroupsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: PatchedGroup}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: PatchedGroup},
        TContext
      > => {

      const mutationOptions = getApiV1GroupsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows groups to be viewed or edited.
 */
export const apiV1GroupsDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/groups/${id}/`,options
    );
  }



export const getApiV1GroupsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1GroupsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1GroupsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1GroupsDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiV1GroupsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiV1GroupsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1GroupsDestroy>>>
    
    export type ApiV1GroupsDestroyMutationError = AxiosError<unknown>

    export const useApiV1GroupsDestroy = <TData = Awaited<ReturnType<typeof apiV1GroupsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiV1GroupsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1InstrumentList = (
    params?: ApiV1InstrumentListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedInstrumentList>> => {
    
    
    return axios.default.get(
      `/api/v1/instrument/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1InstrumentListQueryKey = (params?: ApiV1InstrumentListParams,) => {
    return [`/api/v1/instrument/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1InstrumentListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentList>>, TError = AxiosError<unknown>>(params?: ApiV1InstrumentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1InstrumentListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1InstrumentList>>> = ({ signal }) => apiV1InstrumentList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1InstrumentListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentList>>>
export type ApiV1InstrumentListQueryError = AxiosError<unknown>


export function useApiV1InstrumentList<TData = Awaited<ReturnType<typeof apiV1InstrumentList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1InstrumentListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1InstrumentList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1InstrumentList<TData = Awaited<ReturnType<typeof apiV1InstrumentList>>, TError = AxiosError<unknown>>(
 params?: ApiV1InstrumentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1InstrumentList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1InstrumentList<TData = Awaited<ReturnType<typeof apiV1InstrumentList>>, TError = AxiosError<unknown>>(
 params?: ApiV1InstrumentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1InstrumentList<TData = Awaited<ReturnType<typeof apiV1InstrumentList>>, TError = AxiosError<unknown>>(
 params?: ApiV1InstrumentListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1InstrumentListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1InstrumentCreate = (
    instrument: NonReadonly<Instrument>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Instrument>> => {
    
    
    return axios.default.post(
      `/api/v1/instrument/`,
      instrument,options
    );
  }



export const getApiV1InstrumentCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Instrument>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1InstrumentCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1InstrumentCreate>>, {data: NonReadonly<Instrument>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1InstrumentCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Instrument>}, TContext>}

    export type ApiV1InstrumentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentCreate>>>
    export type ApiV1InstrumentCreateMutationBody = NonReadonly<Instrument>
    export type ApiV1InstrumentCreateMutationError = AxiosError<unknown>

    export const useApiV1InstrumentCreate = <TData = Awaited<ReturnType<typeof apiV1InstrumentCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Instrument>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Instrument>},
        TContext
      > => {

      const mutationOptions = getApiV1InstrumentCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1InstrumentRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Instrument>> => {
    
    
    return axios.default.get(
      `/api/v1/instrument/${id}/`,options
    );
  }


export const getApiV1InstrumentRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/instrument/${id}/`] as const;
    }

    
export const getApiV1InstrumentRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1InstrumentRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>> = ({ signal }) => apiV1InstrumentRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1InstrumentRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>>
export type ApiV1InstrumentRetrieveQueryError = AxiosError<unknown>


export function useApiV1InstrumentRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1InstrumentRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1InstrumentRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1InstrumentRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1InstrumentRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1InstrumentUpdate = (
    id: string,
    instrument: NonReadonly<Instrument>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Instrument>> => {
    
    
    return axios.default.put(
      `/api/v1/instrument/${id}/`,
      instrument,options
    );
  }



export const getApiV1InstrumentUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Instrument>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1InstrumentUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1InstrumentUpdate>>, {id: string;data: NonReadonly<Instrument>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1InstrumentUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Instrument>}, TContext>}

    export type ApiV1InstrumentUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentUpdate>>>
    export type ApiV1InstrumentUpdateMutationBody = NonReadonly<Instrument>
    export type ApiV1InstrumentUpdateMutationError = AxiosError<unknown>

    export const useApiV1InstrumentUpdate = <TData = Awaited<ReturnType<typeof apiV1InstrumentUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Instrument>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Instrument>},
        TContext
      > => {

      const mutationOptions = getApiV1InstrumentUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1InstrumentPartialUpdate = (
    id: string,
    patchedInstrument: NonReadonly<PatchedInstrument>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Instrument>> => {
    
    
    return axios.default.patch(
      `/api/v1/instrument/${id}/`,
      patchedInstrument,options
    );
  }



export const getApiV1InstrumentPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedInstrument>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1InstrumentPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1InstrumentPartialUpdate>>, {id: string;data: NonReadonly<PatchedInstrument>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1InstrumentPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedInstrument>}, TContext>}

    export type ApiV1InstrumentPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentPartialUpdate>>>
    export type ApiV1InstrumentPartialUpdateMutationBody = NonReadonly<PatchedInstrument>
    export type ApiV1InstrumentPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1InstrumentPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1InstrumentPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedInstrument>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedInstrument>},
        TContext
      > => {

      const mutationOptions = getApiV1InstrumentPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1InstrumentDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/instrument/${id}/`,options
    );
  }



export const getApiV1InstrumentDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1InstrumentDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1InstrumentDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1InstrumentDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1InstrumentDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentDestroy>>>
    
    export type ApiV1InstrumentDestroyMutationError = AxiosError<unknown>

    export const useApiV1InstrumentDestroy = <TData = Awaited<ReturnType<typeof apiV1InstrumentDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1InstrumentDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1InstrumentMetadataRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Instrument>> => {
    
    
    return axios.default.get(
      `/api/v1/instrument/metadata/`,options
    );
  }


export const getApiV1InstrumentMetadataRetrieveQueryKey = () => {
    return [`/api/v1/instrument/metadata/`] as const;
    }

    
export const getApiV1InstrumentMetadataRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1InstrumentMetadataRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>> = ({ signal }) => apiV1InstrumentMetadataRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1InstrumentMetadataRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>>
export type ApiV1InstrumentMetadataRetrieveQueryError = AxiosError<unknown>


export function useApiV1InstrumentMetadataRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1InstrumentMetadataRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1InstrumentMetadataRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1InstrumentMetadataRetrieve<TData = Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1InstrumentMetadataRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1InstrumentMetadataRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1ProfileList = (
    params?: ApiV1ProfileListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedProfileList>> => {
    
    
    return axios.default.get(
      `/api/v1/profile/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1ProfileListQueryKey = (params?: ApiV1ProfileListParams,) => {
    return [`/api/v1/profile/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1ProfileListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ProfileList>>, TError = AxiosError<unknown>>(params?: ApiV1ProfileListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ProfileListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ProfileList>>> = ({ signal }) => apiV1ProfileList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ProfileListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ProfileList>>>
export type ApiV1ProfileListQueryError = AxiosError<unknown>


export function useApiV1ProfileList<TData = Awaited<ReturnType<typeof apiV1ProfileList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1ProfileListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProfileList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProfileList<TData = Awaited<ReturnType<typeof apiV1ProfileList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ProfileListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProfileList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProfileList<TData = Awaited<ReturnType<typeof apiV1ProfileList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ProfileListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ProfileList<TData = Awaited<ReturnType<typeof apiV1ProfileList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ProfileListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ProfileListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1ProfileCreate = (
    profile: NonReadonly<Profile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Profile>> => {
    
    
    return axios.default.post(
      `/api/v1/profile/`,
      profile,options
    );
  }



export const getApiV1ProfileCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProfileCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Profile>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProfileCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProfileCreate>>, {data: NonReadonly<Profile>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1ProfileCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Profile>}, TContext>}

    export type ApiV1ProfileCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProfileCreate>>>
    export type ApiV1ProfileCreateMutationBody = NonReadonly<Profile>
    export type ApiV1ProfileCreateMutationError = AxiosError<unknown>

    export const useApiV1ProfileCreate = <TData = Awaited<ReturnType<typeof apiV1ProfileCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Profile>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Profile>},
        TContext
      > => {

      const mutationOptions = getApiV1ProfileCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1ProfileRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Profile>> => {
    
    
    return axios.default.get(
      `/api/v1/profile/${id}/`,options
    );
  }


export const getApiV1ProfileRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/profile/${id}/`] as const;
    }

    
export const getApiV1ProfileRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ProfileRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>> = ({ signal }) => apiV1ProfileRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ProfileRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>>
export type ApiV1ProfileRetrieveQueryError = AxiosError<unknown>


export function useApiV1ProfileRetrieve<TData = Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProfileRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProfileRetrieve<TData = Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProfileRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProfileRetrieve<TData = Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ProfileRetrieve<TData = Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProfileRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ProfileRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1ProfileUpdate = (
    id: string,
    profile: NonReadonly<Profile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Profile>> => {
    
    
    return axios.default.put(
      `/api/v1/profile/${id}/`,
      profile,options
    );
  }



export const getApiV1ProfileUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProfileUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Profile>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProfileUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProfileUpdate>>, {id: string;data: NonReadonly<Profile>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1ProfileUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Profile>}, TContext>}

    export type ApiV1ProfileUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProfileUpdate>>>
    export type ApiV1ProfileUpdateMutationBody = NonReadonly<Profile>
    export type ApiV1ProfileUpdateMutationError = AxiosError<unknown>

    export const useApiV1ProfileUpdate = <TData = Awaited<ReturnType<typeof apiV1ProfileUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Profile>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Profile>},
        TContext
      > => {

      const mutationOptions = getApiV1ProfileUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1ProfilePartialUpdate = (
    id: string,
    patchedProfile: NonReadonly<PatchedProfile>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Profile>> => {
    
    
    return axios.default.patch(
      `/api/v1/profile/${id}/`,
      patchedProfile,options
    );
  }



export const getApiV1ProfilePartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProfilePartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedProfile>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProfilePartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProfilePartialUpdate>>, {id: string;data: NonReadonly<PatchedProfile>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1ProfilePartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedProfile>}, TContext>}

    export type ApiV1ProfilePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProfilePartialUpdate>>>
    export type ApiV1ProfilePartialUpdateMutationBody = NonReadonly<PatchedProfile>
    export type ApiV1ProfilePartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1ProfilePartialUpdate = <TData = Awaited<ReturnType<typeof apiV1ProfilePartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedProfile>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedProfile>},
        TContext
      > => {

      const mutationOptions = getApiV1ProfilePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1ProfileDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/profile/${id}/`,options
    );
  }



export const getApiV1ProfileDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProfileDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProfileDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProfileDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1ProfileDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1ProfileDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProfileDestroy>>>
    
    export type ApiV1ProfileDestroyMutationError = AxiosError<unknown>

    export const useApiV1ProfileDestroy = <TData = Awaited<ReturnType<typeof apiV1ProfileDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1ProfileDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows project to be viewed or edited.
 */
export const apiV1ProjectsList = (
    params?: ApiV1ProjectsListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedProjectResponseList>> => {
    
    
    return axios.default.get(
      `/api/v1/projects/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1ProjectsListQueryKey = (params?: ApiV1ProjectsListParams,) => {
    return [`/api/v1/projects/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1ProjectsListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ProjectsList>>, TError = AxiosError<unknown>>(params?: ApiV1ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ProjectsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ProjectsList>>> = ({ signal }) => apiV1ProjectsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ProjectsListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ProjectsList>>>
export type ApiV1ProjectsListQueryError = AxiosError<unknown>


export function useApiV1ProjectsList<TData = Awaited<ReturnType<typeof apiV1ProjectsList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1ProjectsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProjectsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProjectsList<TData = Awaited<ReturnType<typeof apiV1ProjectsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProjectsList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProjectsList<TData = Awaited<ReturnType<typeof apiV1ProjectsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ProjectsList<TData = Awaited<ReturnType<typeof apiV1ProjectsList>>, TError = AxiosError<unknown>>(
 params?: ApiV1ProjectsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ProjectsListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows project to be viewed or edited.
 */
export const apiV1ProjectsCreate = (
    project: NonReadonly<Project>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectResponse>> => {
    
    
    return axios.default.post(
      `/api/v1/projects/`,
      project,options
    );
  }



export const getApiV1ProjectsCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProjectsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Project>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProjectsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProjectsCreate>>, {data: NonReadonly<Project>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1ProjectsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Project>}, TContext>}

    export type ApiV1ProjectsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProjectsCreate>>>
    export type ApiV1ProjectsCreateMutationBody = NonReadonly<Project>
    export type ApiV1ProjectsCreateMutationError = AxiosError<unknown>

    export const useApiV1ProjectsCreate = <TData = Awaited<ReturnType<typeof apiV1ProjectsCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Project>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Project>},
        TContext
      > => {

      const mutationOptions = getApiV1ProjectsCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows project to be viewed or edited.
 */
export const apiV1ProjectsRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectResponse>> => {
    
    
    return axios.default.get(
      `/api/v1/projects/${id}/`,options
    );
  }


export const getApiV1ProjectsRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/projects/${id}/`] as const;
    }

    
export const getApiV1ProjectsRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ProjectsRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>> = ({ signal }) => apiV1ProjectsRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ProjectsRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>>
export type ApiV1ProjectsRetrieveQueryError = AxiosError<unknown>


export function useApiV1ProjectsRetrieve<TData = Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProjectsRetrieve<TData = Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ProjectsRetrieve<TData = Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ProjectsRetrieve<TData = Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ProjectsRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ProjectsRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows project to be viewed or edited.
 */
export const apiV1ProjectsUpdate = (
    id: string,
    project: NonReadonly<Project>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectResponse>> => {
    
    
    return axios.default.put(
      `/api/v1/projects/${id}/`,
      project,options
    );
  }



export const getApiV1ProjectsUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProjectsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Project>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProjectsUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProjectsUpdate>>, {id: string;data: NonReadonly<Project>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1ProjectsUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Project>}, TContext>}

    export type ApiV1ProjectsUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProjectsUpdate>>>
    export type ApiV1ProjectsUpdateMutationBody = NonReadonly<Project>
    export type ApiV1ProjectsUpdateMutationError = AxiosError<unknown>

    export const useApiV1ProjectsUpdate = <TData = Awaited<ReturnType<typeof apiV1ProjectsUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Project>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Project>},
        TContext
      > => {

      const mutationOptions = getApiV1ProjectsUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows project to be viewed or edited.
 */
export const apiV1ProjectsPartialUpdate = (
    id: string,
    patchedProject: NonReadonly<PatchedProject>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ProjectResponse>> => {
    
    
    return axios.default.patch(
      `/api/v1/projects/${id}/`,
      patchedProject,options
    );
  }



export const getApiV1ProjectsPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProjectsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedProject>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProjectsPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProjectsPartialUpdate>>, {id: string;data: NonReadonly<PatchedProject>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1ProjectsPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedProject>}, TContext>}

    export type ApiV1ProjectsPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProjectsPartialUpdate>>>
    export type ApiV1ProjectsPartialUpdateMutationBody = NonReadonly<PatchedProject>
    export type ApiV1ProjectsPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1ProjectsPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1ProjectsPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedProject>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedProject>},
        TContext
      > => {

      const mutationOptions = getApiV1ProjectsPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows project to be viewed or edited.
 */
export const apiV1ProjectsDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/projects/${id}/`,options
    );
  }



export const getApiV1ProjectsDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1ProjectsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1ProjectsDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1ProjectsDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1ProjectsDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1ProjectsDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1ProjectsDestroy>>>
    
    export type ApiV1ProjectsDestroyMutationError = AxiosError<unknown>

    export const useApiV1ProjectsDestroy = <TData = Awaited<ReturnType<typeof apiV1ProjectsDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1ProjectsDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1ReservationRetrieve = (
    params: ApiV1ReservationRetrieveParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Reservation[]>> => {
    
    
    return axios.default.get(
      `/api/v1/reservation/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1ReservationRetrieveQueryKey = (params: ApiV1ReservationRetrieveParams,) => {
    return [`/api/v1/reservation/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1ReservationRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError = AxiosError<unknown>>(params: ApiV1ReservationRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ReservationRetrieveQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>> = ({ signal }) => apiV1ReservationRetrieve(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ReservationRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>>
export type ApiV1ReservationRetrieveQueryError = AxiosError<unknown>


export function useApiV1ReservationRetrieve<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError = AxiosError<unknown>>(
 params: ApiV1ReservationRetrieveParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ReservationRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ReservationRetrieve<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError = AxiosError<unknown>>(
 params: ApiV1ReservationRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ReservationRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ReservationRetrieve<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError = AxiosError<unknown>>(
 params: ApiV1ReservationRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ReservationRetrieve<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError = AxiosError<unknown>>(
 params: ApiV1ReservationRetrieveParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ReservationRetrieveQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1ReservationRetrieve2 = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Reservation>> => {
    
    
    return axios.default.get(
      `/api/v1/reservation/${id}/`,options
    );
  }


export const getApiV1ReservationRetrieve2QueryKey = (id: string,) => {
    return [`/api/v1/reservation/${id}/`] as const;
    }

    
export const getApiV1ReservationRetrieve2QueryOptions = <TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError = AxiosError<void>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1ReservationRetrieve2QueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>> = ({ signal }) => apiV1ReservationRetrieve2(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1ReservationRetrieve2QueryResult = NonNullable<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>>
export type ApiV1ReservationRetrieve2QueryError = AxiosError<void>


export function useApiV1ReservationRetrieve2<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError = AxiosError<void>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ReservationRetrieve2<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError = AxiosError<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1ReservationRetrieve2<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError = AxiosError<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1ReservationRetrieve2<TData = Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError = AxiosError<void>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1ReservationRetrieve2>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1ReservationRetrieve2QueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1SchemasList = (
    params?: ApiV1SchemasListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedSchemaList>> => {
    
    
    return axios.default.get(
      `/api/v1/schemas/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1SchemasListQueryKey = (params?: ApiV1SchemasListParams,) => {
    return [`/api/v1/schemas/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1SchemasListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1SchemasList>>, TError = AxiosError<unknown>>(params?: ApiV1SchemasListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1SchemasListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1SchemasList>>> = ({ signal }) => apiV1SchemasList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1SchemasListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1SchemasList>>>
export type ApiV1SchemasListQueryError = AxiosError<unknown>


export function useApiV1SchemasList<TData = Awaited<ReturnType<typeof apiV1SchemasList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1SchemasListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1SchemasList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1SchemasList<TData = Awaited<ReturnType<typeof apiV1SchemasList>>, TError = AxiosError<unknown>>(
 params?: ApiV1SchemasListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1SchemasList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1SchemasList<TData = Awaited<ReturnType<typeof apiV1SchemasList>>, TError = AxiosError<unknown>>(
 params?: ApiV1SchemasListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1SchemasList<TData = Awaited<ReturnType<typeof apiV1SchemasList>>, TError = AxiosError<unknown>>(
 params?: ApiV1SchemasListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1SchemasListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1SchemasCreate = (
    schema: NonReadonly<Schema>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Schema>> => {
    
    
    return axios.default.post(
      `/api/v1/schemas/`,
      schema,options
    );
  }



export const getApiV1SchemasCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1SchemasCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Schema>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1SchemasCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1SchemasCreate>>, {data: NonReadonly<Schema>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1SchemasCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<Schema>}, TContext>}

    export type ApiV1SchemasCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1SchemasCreate>>>
    export type ApiV1SchemasCreateMutationBody = NonReadonly<Schema>
    export type ApiV1SchemasCreateMutationError = AxiosError<unknown>

    export const useApiV1SchemasCreate = <TData = Awaited<ReturnType<typeof apiV1SchemasCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<Schema>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<Schema>},
        TContext
      > => {

      const mutationOptions = getApiV1SchemasCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1SchemasRetrieve = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Schema>> => {
    
    
    return axios.default.get(
      `/api/v1/schemas/${id}/`,options
    );
  }


export const getApiV1SchemasRetrieveQueryKey = (id: string,) => {
    return [`/api/v1/schemas/${id}/`] as const;
    }

    
export const getApiV1SchemasRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1SchemasRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>> = ({ signal }) => apiV1SchemasRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1SchemasRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>>
export type ApiV1SchemasRetrieveQueryError = AxiosError<unknown>


export function useApiV1SchemasRetrieve<TData = Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1SchemasRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1SchemasRetrieve<TData = Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1SchemasRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1SchemasRetrieve<TData = Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1SchemasRetrieve<TData = Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1SchemasRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1SchemasRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const apiV1SchemasUpdate = (
    id: string,
    schema: NonReadonly<Schema>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Schema>> => {
    
    
    return axios.default.put(
      `/api/v1/schemas/${id}/`,
      schema,options
    );
  }



export const getApiV1SchemasUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1SchemasUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Schema>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1SchemasUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1SchemasUpdate>>, {id: string;data: NonReadonly<Schema>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1SchemasUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Schema>}, TContext>}

    export type ApiV1SchemasUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1SchemasUpdate>>>
    export type ApiV1SchemasUpdateMutationBody = NonReadonly<Schema>
    export type ApiV1SchemasUpdateMutationError = AxiosError<unknown>

    export const useApiV1SchemasUpdate = <TData = Awaited<ReturnType<typeof apiV1SchemasUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<Schema>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<Schema>},
        TContext
      > => {

      const mutationOptions = getApiV1SchemasUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1SchemasPartialUpdate = (
    id: string,
    patchedSchema: NonReadonly<PatchedSchema>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Schema>> => {
    
    
    return axios.default.patch(
      `/api/v1/schemas/${id}/`,
      patchedSchema,options
    );
  }



export const getApiV1SchemasPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1SchemasPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedSchema>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1SchemasPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1SchemasPartialUpdate>>, {id: string;data: NonReadonly<PatchedSchema>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1SchemasPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedSchema>}, TContext>}

    export type ApiV1SchemasPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1SchemasPartialUpdate>>>
    export type ApiV1SchemasPartialUpdateMutationBody = NonReadonly<PatchedSchema>
    export type ApiV1SchemasPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1SchemasPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1SchemasPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string;data: NonReadonly<PatchedSchema>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string;data: NonReadonly<PatchedSchema>},
        TContext
      > => {

      const mutationOptions = getApiV1SchemasPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1SchemasDestroy = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/schemas/${id}/`,options
    );
  }



export const getApiV1SchemasDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1SchemasDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1SchemasDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1SchemasDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1SchemasDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1SchemasDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1SchemasDestroy>>>
    
    export type ApiV1SchemasDestroyMutationError = AxiosError<unknown>

    export const useApiV1SchemasDestroy = <TData = Awaited<ReturnType<typeof apiV1SchemasDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1SchemasDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const apiV1TempTokenCreate = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/api/v1/temp-token/${id}/`,undefined,options
    );
  }



export const getApiV1TempTokenCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1TempTokenCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1TempTokenCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1TempTokenCreate>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  apiV1TempTokenCreate(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: string}, TContext>}

    export type ApiV1TempTokenCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1TempTokenCreate>>>
    
    export type ApiV1TempTokenCreateMutationError = AxiosError<unknown>

    export const useApiV1TempTokenCreate = <TData = Awaited<ReturnType<typeof apiV1TempTokenCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getApiV1TempTokenCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows users to be viewed or edited.
 */
export const apiV1UsersList = (
    params?: ApiV1UsersListParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PaginatedUserList>> => {
    
    
    return axios.default.get(
      `/api/v1/users/`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getApiV1UsersListQueryKey = (params?: ApiV1UsersListParams,) => {
    return [`/api/v1/users/`, ...(params ? [params]: [])] as const;
    }

    
export const getApiV1UsersListQueryOptions = <TData = Awaited<ReturnType<typeof apiV1UsersList>>, TError = AxiosError<unknown>>(params?: ApiV1UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1UsersListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1UsersList>>> = ({ signal }) => apiV1UsersList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1UsersListQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1UsersList>>>
export type ApiV1UsersListQueryError = AxiosError<unknown>


export function useApiV1UsersList<TData = Awaited<ReturnType<typeof apiV1UsersList>>, TError = AxiosError<unknown>>(
 params: undefined |  ApiV1UsersListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1UsersList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1UsersList<TData = Awaited<ReturnType<typeof apiV1UsersList>>, TError = AxiosError<unknown>>(
 params?: ApiV1UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1UsersList>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1UsersList<TData = Awaited<ReturnType<typeof apiV1UsersList>>, TError = AxiosError<unknown>>(
 params?: ApiV1UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1UsersList<TData = Awaited<ReturnType<typeof apiV1UsersList>>, TError = AxiosError<unknown>>(
 params?: ApiV1UsersListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1UsersListQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows users to be viewed or edited.
 */
export const apiV1UsersCreate = (
    user: NonReadonly<User>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.post(
      `/api/v1/users/`,
      user,options
    );
  }



export const getApiV1UsersCreateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1UsersCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<User>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1UsersCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1UsersCreate>>, {data: NonReadonly<User>}> = (props) => {
          const {data} = props ?? {};

          return  apiV1UsersCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: NonReadonly<User>}, TContext>}

    export type ApiV1UsersCreateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1UsersCreate>>>
    export type ApiV1UsersCreateMutationBody = NonReadonly<User>
    export type ApiV1UsersCreateMutationError = AxiosError<unknown>

    export const useApiV1UsersCreate = <TData = Awaited<ReturnType<typeof apiV1UsersCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: NonReadonly<User>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {data: NonReadonly<User>},
        TContext
      > => {

      const mutationOptions = getApiV1UsersCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows users to be viewed or edited.
 */
export const apiV1UsersRetrieve = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.get(
      `/api/v1/users/${id}/`,options
    );
  }


export const getApiV1UsersRetrieveQueryKey = (id: number,) => {
    return [`/api/v1/users/${id}/`] as const;
    }

    
export const getApiV1UsersRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError = AxiosError<unknown>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getApiV1UsersRetrieveQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof apiV1UsersRetrieve>>> = ({ signal }) => apiV1UsersRetrieve(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiV1UsersRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof apiV1UsersRetrieve>>>
export type ApiV1UsersRetrieveQueryError = AxiosError<unknown>


export function useApiV1UsersRetrieve<TData = Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1UsersRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1UsersRetrieve<TData = Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiV1UsersRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiV1UsersRetrieve<TData = Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useApiV1UsersRetrieve<TData = Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError = AxiosError<unknown>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof apiV1UsersRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getApiV1UsersRetrieveQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * API endpoint that allows users to be viewed or edited.
 */
export const apiV1UsersUpdate = (
    id: number,
    user: NonReadonly<User>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.put(
      `/api/v1/users/${id}/`,
      user,options
    );
  }



export const getApiV1UsersUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1UsersUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<User>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1UsersUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1UsersUpdate>>, {id: number;data: NonReadonly<User>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1UsersUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<User>}, TContext>}

    export type ApiV1UsersUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1UsersUpdate>>>
    export type ApiV1UsersUpdateMutationBody = NonReadonly<User>
    export type ApiV1UsersUpdateMutationError = AxiosError<unknown>

    export const useApiV1UsersUpdate = <TData = Awaited<ReturnType<typeof apiV1UsersUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<User>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<User>},
        TContext
      > => {

      const mutationOptions = getApiV1UsersUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows users to be viewed or edited.
 */
export const apiV1UsersPartialUpdate = (
    id: number,
    patchedUser: NonReadonly<PatchedUser>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<User>> => {
    
    
    return axios.default.patch(
      `/api/v1/users/${id}/`,
      patchedUser,options
    );
  }



export const getApiV1UsersPartialUpdateMutationOptions = <TData = Awaited<ReturnType<typeof apiV1UsersPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedUser>}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1UsersPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1UsersPartialUpdate>>, {id: number;data: NonReadonly<PatchedUser>}> = (props) => {
          const {id,data} = props ?? {};

          return  apiV1UsersPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedUser>}, TContext>}

    export type ApiV1UsersPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1UsersPartialUpdate>>>
    export type ApiV1UsersPartialUpdateMutationBody = NonReadonly<PatchedUser>
    export type ApiV1UsersPartialUpdateMutationError = AxiosError<unknown>

    export const useApiV1UsersPartialUpdate = <TData = Awaited<ReturnType<typeof apiV1UsersPartialUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number;data: NonReadonly<PatchedUser>}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number;data: NonReadonly<PatchedUser>},
        TContext
      > => {

      const mutationOptions = getApiV1UsersPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * API endpoint that allows users to be viewed or edited.
 */
export const apiV1UsersDestroy = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/api/v1/users/${id}/`,options
    );
  }



export const getApiV1UsersDestroyMutationOptions = <TData = Awaited<ReturnType<typeof apiV1UsersDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['apiV1UsersDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof apiV1UsersDestroy>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  apiV1UsersDestroy(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{id: number}, TContext>}

    export type ApiV1UsersDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof apiV1UsersDestroy>>>
    
    export type ApiV1UsersDestroyMutationError = AxiosError<unknown>

    export const useApiV1UsersDestroy = <TData = Awaited<ReturnType<typeof apiV1UsersDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getApiV1UsersDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const dataciteApiV1DoisRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.get(
      `/datacite-api/v1/dois/`,options
    );
  }


export const getDataciteApiV1DoisRetrieveQueryKey = () => {
    return [`/datacite-api/v1/dois/`] as const;
    }

    
export const getDataciteApiV1DoisRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDataciteApiV1DoisRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>> = ({ signal }) => dataciteApiV1DoisRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DataciteApiV1DoisRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>>
export type DataciteApiV1DoisRetrieveQueryError = AxiosError<unknown>


export function useDataciteApiV1DoisRetrieve<TData = Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataciteApiV1DoisRetrieve<TData = Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDataciteApiV1DoisRetrieve<TData = Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useDataciteApiV1DoisRetrieve<TData = Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof dataciteApiV1DoisRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDataciteApiV1DoisRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const dataciteApiV1DoisCreate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/datacite-api/v1/dois/`,undefined,options
    );
  }



export const getDataciteApiV1DoisCreateMutationOptions = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['dataciteApiV1DoisCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof dataciteApiV1DoisCreate>>, void> = () => {
          

          return  dataciteApiV1DoisCreate(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type DataciteApiV1DoisCreateMutationResult = NonNullable<Awaited<ReturnType<typeof dataciteApiV1DoisCreate>>>
    
    export type DataciteApiV1DoisCreateMutationError = AxiosError<unknown>

    export const useDataciteApiV1DoisCreate = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDataciteApiV1DoisCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const dataciteApiV1DoisUpdate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.put(
      `/datacite-api/v1/dois/`,undefined,options
    );
  }



export const getDataciteApiV1DoisUpdateMutationOptions = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['dataciteApiV1DoisUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof dataciteApiV1DoisUpdate>>, void> = () => {
          

          return  dataciteApiV1DoisUpdate(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type DataciteApiV1DoisUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof dataciteApiV1DoisUpdate>>>
    
    export type DataciteApiV1DoisUpdateMutationError = AxiosError<unknown>

    export const useDataciteApiV1DoisUpdate = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisUpdate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDataciteApiV1DoisUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const dataciteApiV1DoisDestroy = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.delete(
      `/datacite-api/v1/dois/`,options
    );
  }



export const getDataciteApiV1DoisDestroyMutationOptions = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['dataciteApiV1DoisDestroy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof dataciteApiV1DoisDestroy>>, void> = () => {
          

          return  dataciteApiV1DoisDestroy(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type DataciteApiV1DoisDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof dataciteApiV1DoisDestroy>>>
    
    export type DataciteApiV1DoisDestroyMutationError = AxiosError<unknown>

    export const useDataciteApiV1DoisDestroy = <TData = Awaited<ReturnType<typeof dataciteApiV1DoisDestroy>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDataciteApiV1DoisDestroyMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const onedataApiV1FilesRetrieve = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.get(
      `/onedata-api/v1/files/`,options
    );
  }


export const getOnedataApiV1FilesRetrieveQueryKey = () => {
    return [`/onedata-api/v1/files/`] as const;
    }

    
export const getOnedataApiV1FilesRetrieveQueryOptions = <TData = Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOnedataApiV1FilesRetrieveQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>> = ({ signal }) => onedataApiV1FilesRetrieve({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type OnedataApiV1FilesRetrieveQueryResult = NonNullable<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>>
export type OnedataApiV1FilesRetrieveQueryError = AxiosError<unknown>


export function useOnedataApiV1FilesRetrieve<TData = Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOnedataApiV1FilesRetrieve<TData = Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>,
          TError,
          TData
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useOnedataApiV1FilesRetrieve<TData = Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useOnedataApiV1FilesRetrieve<TData = Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof onedataApiV1FilesRetrieve>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getOnedataApiV1FilesRetrieveQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const onedataApiV1FilesCreate = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.default.post(
      `/onedata-api/v1/files/`,undefined,options
    );
  }



export const getOnedataApiV1FilesCreateMutationOptions = <TData = Awaited<ReturnType<typeof onedataApiV1FilesCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
) => {
const mutationKey = ['onedataApiV1FilesCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof onedataApiV1FilesCreate>>, void> = () => {
          

          return  onedataApiV1FilesCreate(axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,void, TContext>}

    export type OnedataApiV1FilesCreateMutationResult = NonNullable<Awaited<ReturnType<typeof onedataApiV1FilesCreate>>>
    
    export type OnedataApiV1FilesCreateMutationError = AxiosError<unknown>

    export const useOnedataApiV1FilesCreate = <TData = Awaited<ReturnType<typeof onedataApiV1FilesCreate>>, TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,void, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        TData,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getOnedataApiV1FilesCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
